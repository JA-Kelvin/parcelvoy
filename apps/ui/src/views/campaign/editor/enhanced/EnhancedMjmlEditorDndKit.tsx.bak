// Enhanced MJML Editor for Parcelvoy using DndKit
import React, { useCallback, useEffect, useReducer, useState, useMemo, memo } from 'react'
import {
    DndContext,
    DragEndEvent,
    DragOverEvent,
    DragStartEvent,
    MouseSensor,
    TouchSensor,
    useSensor,
    useSensors,
    DragOverlay,
    closestCenter,
    defaultDropAnimation,
    PointerSensor,
} from '@dnd-kit/core'
import { EditorElement, HistoryState, EnhancedTemplate, EditorAction, ComponentDefinition } from './types'
import {
    parseMJMLString,
    editorElementsToMjmlString,
    mjmlToHtml,
    createDefaultMjmlStructure,
    generateId,
} from './utils/mjmlParser'
import { ComponentsPanelDndKit, CanvasDndKit, PropertiesPanel, EnhancedPreviewModal, ImportMjmlModal, ErrorBoundary } from './components'
import './EnhancedMjmlEditor.css'
import { toast } from 'react-hot-toast/headless'
// Performance monitoring
const DEBUG_PERFORMANCE = false

interface EnhancedMjmlEditorProps {
    template: EnhancedTemplate
    onTemplateChange: (template: EnhancedTemplate) => void
    onTemplateSave?: (template: EnhancedTemplate) => Promise<void>
    _resources?: any[]
    isPreviewMode?: boolean
    isSaving?: boolean
}

// Performance monitoring function
const measurePerformance = (label: string, fn: () => any) => {
    if (!DEBUG_PERFORMANCE) return fn()
    
                ...state,
                selectedElementId: payload.elementId,
            }
        }

        case 'UNDO': {
            if (state.history.length === 0) return state
            const previous = state.history[state.history.length - 1]
            return {
                present: previous,
                history: state.history.slice(0, -1),
                future: [state.present, ...state.future.slice(0, 49)],
                selectedElementId: null,
                templateId: state.templateId,
            }
        }

        case 'REDO': {
            if (state.future.length === 0) return state
            const next = state.future[0]
            return {
                present: next,
                history: [...state.history.slice(-49), state.present],
                future: state.future.slice(1),
                selectedElementId: null,
                templateId: state.templateId,
            }
        }

        case 'LOAD_TEMPLATE': {
            const { elements, templateId } = payload
            return {
                present: elements,
                history: [],
                future: [],
                selectedElementId: null,
                templateId,
            }
        }

        case 'CLEAR_CANVAS': {
            const defaultElements = createDefaultMjmlStructure()
            return {
                present: defaultElements,
                history: [...state.history.slice(-49), state.present],
                future: [],
                selectedElementId: null,
                templateId: state.templateId,
            }
        }

        default:
            return state
    }
}

// Helper functions for element manipulation
const addElementRecursive = (elements: EditorElement[] | any, newElement: EditorElement, parentId?: string, index?: number): EditorElement[] => {
    // Ensure elements is an array before mapping
    const safeElements = Array.isArray(elements) ? elements : []

    return safeElements.map(element => {
        if (element.id === parentId) {
            const children = element.children || []
            const insertIndex = index !== undefined && index >= 0 && index <= children.length
                ? index
                : children.length

            const updatedChildren = [
                ...children.slice(0, insertIndex),
                newElement,
                ...children.slice(insertIndex),
            ]

            return { ...element, children: updatedChildren }
        }

        if (element.children && element.children.length > 0) {
            return {
                ...element,
                children: addElementRecursive(element.children, newElement, parentId, index),
            }
        }

        return element
    })
}

const updateElementRecursive = (elements: EditorElement[], elementId: string, updatedAttributes?: Record<string, any>, updatedContent?: string): EditorElement[] => {
    return elements.map(element => {
        if (element.id === elementId) {
            return {
                ...element,
                attributes: updatedAttributes !== undefined ? { ...element.attributes, ...updatedAttributes } : element.attributes,
                content: updatedContent !== undefined ? updatedContent : element.content,
            }
        }

        if (element.children && element.children.length > 0) {
            return {
                ...element,
                children: updateElementRecursive(element.children, elementId, updatedAttributes, updatedContent),
            }
        }

        return element
    })
}

const deleteElementRecursive = (elements: EditorElement[] | any, elementId: string): EditorElement[] => {
    // Ensure elements is an array before filtering and mapping
    const safeElements = Array.isArray(elements) ? elements : []

    return safeElements.filter(element => element.id !== elementId)
        .map(element => {
            if (element.children && element.children.length > 0) {
                return {
                    ...element,
                    children: deleteElementRecursive(element.children, elementId),
                }
            }
            return element
        })
}

const EnhancedMjmlEditorDndKit: React.FC<EnhancedMjmlEditorProps> = ({
    template,
    onTemplateChange,
    onTemplateSave,
    _resources = [],
    isPreviewMode = false,
    isSaving = false,
}) => {
    // Initialize editor state
    const getInitialState = (): HistoryState => {
        try {
            if (template?.data?.elements) {
                // If template has elements data, use it
                return {
                    present: template.data.elements,
                    history: [],
                    future: [],
                    selectedElementId: null,
                    templateId: template.id,
                }
            }

            // If template has MJML but no editor data, parse it
            if (template?.data?.mjml) {
                try {
                    const parsedElements = parseMJMLString(template.data.mjml)
                    return {
                        present: parsedElements,
                        history: [],
                        future: [],
                        selectedElementId: null,
                        templateId: template.id,
                    }
                } catch (error) {
                    console.error('Error parsing MJML:', error)
                }
            }

            // Default: create new MJML structure
            return {
                present: createDefaultMjmlStructure(),
                history: [],
                future: [],
                selectedElementId: null,
                templateId: template.id,
            }
        } catch (error) {
            console.error('Error initializing editor state:', error)
            return {
                present: createDefaultMjmlStructure(),
                history: [],
                future: [],
                selectedElementId: null,
                templateId: template.id || 'new-template',
            }
        }
    }

    const [editorState, dispatch] = useReducer(editorReducer, null, getInitialState)
    const [showEnhancedPreview, setShowEnhancedPreview] = useState(false)
    const [showImportModal, setShowImportModal] = useState(false)
    const [rightPanelCollapsed, setRightPanelCollapsed] = useState(false)
    const [activeRightTab, setActiveRightTab] = useState<'components' | 'properties'>('components')

    // Find selected element
    const findElementById = (elements: EditorElement[] | any, elementId: string): EditorElement | null => {
        // Ensure elements is an array before iterating
        const safeElements = Array.isArray(elements) ? elements : []

        for (const element of safeElements) {
            if (element.id === elementId) return element
            if (element.children && element.children.length > 0) {
                const found = findElementById(element.children, elementId)
                if (found) return found
            }
        }
        return null
    }

    const selectedElement = editorState.selectedElementId
        ? findElementById(editorState.present, editorState.selectedElementId)
        : null

    // Element manipulation handlers
    const handleElementAdd = useCallback((element: EditorElement, parentId?: string, index?: number) => {
        dispatch({ type: 'ADD_ELEMENT', payload: { element, parentId, index } })
    }, [])

    const handleElementSelect = useCallback((elementId: string | null) => {
        dispatch({ type: 'SELECT_ELEMENT', payload: { elementId } })
    }, [])

    const handleElementUpdate = useCallback((elementId: string, attributes: Record<string, any>, content?: string) => {
        dispatch({ type: 'UPDATE_ELEMENT', payload: { elementId, attributes, content } })
    }, [])

    const handleElementDelete = useCallback((elementId: string) => {
        try {
            // Show loading toast
            const loadingToast = toast.loading('Deleting element...')

            // Use setTimeout to prevent UI freeze
            setTimeout(() => {
                try {
                    // Create a safe copy of the elements
                    const safeElements = Array.isArray(editorState.present) ? [...editorState.present] : []

                    // Delete the element using our recursive function
                    const updatedElements = deleteElementRecursive(safeElements, elementId)

                    // Use LOAD_TEMPLATE instead of DELETE_ELEMENT for better stability
                    dispatch({ type: 'LOAD_TEMPLATE', payload: { elements: updatedElements, templateId: editorState.templateId } })

                    // Clear selection if the deleted element was selected
                    if (editorState.selectedElementId === elementId) {
                        dispatch({ type: 'SELECT_ELEMENT', payload: { elementId: null } })
                    }

                    toast.dismiss(loadingToast)
                    toast.success('Element deleted successfully')
                } catch (error) {
                    console.error('Error deleting element:', error)
                    toast.dismiss(loadingToast)
                    toast.error('Failed to delete element')
                }
            }, 0)
        } catch (error) {
            console.error('Error in handleElementDelete:', error)
            toast.error('Failed to delete element')
        }
    }, [editorState.present, editorState.templateId, editorState.selectedElementId])

    const handleElementMove = useCallback((elementId: string, newParentId: string, newIndex: number) => {
        // First find and "remove" the element
        const elementToMove = findElementById(editorState.present, elementId)
        if (!elementToMove) return

        // Then delete it from its current position
        const elementsAfterDelete = deleteElementRecursive(editorState.present, elementId)

        // Then add it to the new position
        const newElements = addElementRecursive(elementsAfterDelete, elementToMove, newParentId, newIndex)

        // Update state
        dispatch({ type: 'LOAD_TEMPLATE', payload: { elements: newElements, templateId: editorState.templateId } })
    }, [editorState.present, editorState.templateId])

    // History management
    const handleUndo = useCallback(() => {
        dispatch({ type: 'UNDO', payload: {} })
    }, [])

    const handleRedo = useCallback(() => {
        dispatch({ type: 'REDO', payload: {} })
    }, [])

    const handleClearCanvas = useCallback(() => {
        try {
            // Use setTimeout to prevent UI freeze during confirmation dialog
            if (window.confirm('Are you sure you want to clear the canvas? This action cannot be undone.')) {
                // Create default structure first to ensure it's valid
                const defaultElements = createDefaultMjmlStructure()

                // Use setTimeout to move dispatch to next event loop tick
                setTimeout(() => {
                    dispatch({ type: 'LOAD_TEMPLATE', payload: { elements: defaultElements, templateId: editorState.templateId } })
                    toast.success('Canvas cleared successfully')
                }, 0)
            }
        } catch (error) {
            console.error('Error clearing canvas:', error)
            toast.error('Failed to clear canvas')
        }
    }, [editorState.templateId])

    // Save functionality
    const handleSave = useCallback(async () => {
        if (!onTemplateSave) {
            console.warn('No save handler provided')
            return
        }

        // Show loading toast
        const loadingToast = toast.loading('Saving template...')

        // Use setTimeout to prevent UI freeze
        setTimeout(async () => {
            try {
                // Create a safe copy of the elements to avoid reference issues
                const safeElements = Array.isArray(editorState.present) ? [...editorState.present] : []

                // Generate strings in a try-catch to handle potential errors
                const mjmlString = editorElementsToMjmlString(safeElements)
                const htmlString = await mjmlToHtml(mjmlString)

                const updatedTemplate: EnhancedTemplate = {
                    ...template,
                    data: {
                        ...template.data,
                        editor: 'enhanced-visual-dndkit' as const,
                        elements: safeElements,
                        mjml: mjmlString,
                        html: htmlString,
                        metadata: {
                            ...template.data.metadata,
                            lastModified: new Date().toISOString(),
                        },
                    },
                }

                await onTemplateSave(updatedTemplate)
                toast.dismiss(loadingToast)
                toast.success('Template saved successfully')
            } catch (error) {
                console.error('Error saving template:', error)
                toast.dismiss(loadingToast)
                toast.error('Failed to save template')
            }
        }, 0)
    }, [editorState.present, onTemplateSave, template])

    // Import MJML functionality
    const handleImportMjml = useCallback(async (elements: EditorElement[]) => {
        // Show loading toast
        const loadingToast = toast.loading('Importing MJML content...')

        // Use setTimeout to prevent UI freeze
        setTimeout(async () => {
            try {
                // Ensure elements is an array and create a safe copy
                const safeElements = Array.isArray(elements) ? [...elements] : []

                // Generate MJML string from the imported elements
                const mjmlString = editorElementsToMjmlString(safeElements)
                const htmlString = await mjmlToHtml(mjmlString)

                // Use setTimeout for state updates to prevent UI freeze
                setTimeout(() => {
                    // Update editor state
                    dispatch({ type: 'LOAD_TEMPLATE', payload: { elements: safeElements, templateId: editorState.templateId } })

                    // Update template
                    const updatedTemplate: EnhancedTemplate = {
                        ...template,
                        data: {
                            ...template.data,
                            editor: 'enhanced-visual-dndkit' as const,
                            elements: safeElements,
                            mjml: mjmlString,
                            html: htmlString,
                            metadata: {
                                ...template.data.metadata,
                                lastModified: new Date().toISOString(),
                            },
                        },
                    }

                    onTemplateChange(updatedTemplate)
                    toast.dismiss(loadingToast)
                    toast.success('MJML content imported successfully')
                }, 0)
            } catch (error) {
                console.error('Error importing MJML:', error)
                toast.dismiss(loadingToast)
                toast.error('Failed to import MJML content')
            }
        }, 0)
    }, [template, onTemplateChange, editorState.templateId])

    // DND-kit event handlers
    const [activeId, setActiveId] = useState<string | null>(null)
    const [activeComponent, setActiveComponent] = useState<ComponentDefinition | null>(null)
    const [activeDragData, setActiveDragData] = useState<any>(null)

    const sensors = useSensors(
        useSensor(MouseSensor, {
            // Require the mouse to move by 10 pixels before activating
            activationConstraint: {
                distance: 10,
            },
        }),
        useSensor(TouchSensor, {
            // Press delay of 250ms, with tolerance of 5px of movement
            activationConstraint: {
                delay: 250,
                tolerance: 5,
            },
        }),
    )

    const handleDragStart = (event: DragStartEvent) => {
        const { active } = event
        setActiveId(active.id as string)

        // Store the drag data for later use
        setActiveDragData(active.data.current)

        // If this is a component being dragged (not an element)
        if (active.data.current?.component) {
            setActiveComponent(active.data.current.component)
        } else if (active.data.current?.element) {
            // If this is an existing element being dragged
            const _element = active.data.current.element
            setActiveComponent(null)
        }
    }

    const handleDragOver = (_event: DragOverEvent) => {
        // Logic for drag over events if needed
    }

    const handleDragEnd = (event: DragEndEvent) => {
        const { over } = event

        if (over) {
            if (activeComponent) {
                // Handle component drop
                const component = activeComponent
                const parentId = over.id as string

                // Create new element from component definition
                const newElement: EditorElement = {
                    id: generateId(),
                    type: component.type,
                    tagName: component.tagName,
                    attributes: { ...component.defaultAttributes },
                    children: [],
                    content: component.type === 'mj-text'
                        ? 'Your text here'
                        : component.type === 'mj-button'
                            ? 'Click me'
                            : undefined,
                }

                handleElementAdd(newElement, parentId)
            } else if (activeId && activeId !== over.id) {
                // Handle element move
                handleElementMove(activeId, over.id as string, 0)
            }
        }

        // Reset active states
        setActiveId(null)
        setActiveComponent(null)
        setActiveDragData(null)
    }

    // Keyboard shortcuts
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (isPreviewMode) return

            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault()
                handleUndo()
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault()
                handleRedo()
            } else if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault()
                void handleSave()
            } else if (e.key === 'Delete' && selectedElement) {
                e.preventDefault()
                handleElementDelete(selectedElement.id)
            }
        }

        document.addEventListener('keydown', handleKeyDown)
        return () => document.removeEventListener('keydown', handleKeyDown)
    }, [isPreviewMode, handleUndo, handleRedo, handleSave, selectedElement, handleElementDelete])

    // Update template when editor state changes
    useEffect(() => {
        // Skip initial render
        if (!template?.data) return

        const mjmlString = editorElementsToMjmlString(editorState.present)

        // Convert MJML to HTML asynchronously
        mjmlToHtml(mjmlString).then(htmlString => {
            const updatedTemplate: EnhancedTemplate = {
                ...template,
                data: {
                    ...template.data,
                    mjml: mjmlString,
                    html: htmlString,
                },
            }

            onTemplateChange(updatedTemplate)
        }).catch(error => {
            console.error('Error converting MJML to HTML:', error)
        })
    }, [editorState.present, template, onTemplateChange])

    return (
        <DndContext
            sensors={sensors}
            collisionDetection={closestCenter}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDragEnd={handleDragEnd}
        >
            <div className={`enhanced-mjml-editor ${isPreviewMode ? 'preview-mode' : ''}`}>
                {!isPreviewMode && (
                    <div className="editor-toolbar">
                        <div className="toolbar-left">
                            <button
                                className="toolbar-button"
                                onClick={handleUndo}
                                disabled={editorState.history.length === 0}
                                title="Undo (Ctrl+Z)"
                            >
                                <span style={{ fontSize: '16px', marginRight: '4px' }}>‚Ü©</span>
                                Undo
                            </button>
                            <button
                                className="toolbar-button"
                                onClick={handleRedo}
                                disabled={editorState.future.length === 0}
                                title="Redo (Ctrl+Y)"
                            >
                                <span style={{ fontSize: '16px', marginRight: '4px' }}>‚Ü™</span>
                                Redo
                            </button>
                            <div className="toolbar-divider"></div>
                            <button
                                className="toolbar-button"
                                onClick={handleClearCanvas}
                                title="Clear Canvas"
                            >
                                <span style={{ fontSize: '16px', marginRight: '4px' }}>üóë</span>
                                Clear
                            </button>
                            <button
                                className="toolbar-button import-button"
                                onClick={() => setShowImportModal(true)}
                                title="Import MJML"
                            >
                                <span style={{ fontSize: '16px', marginRight: '4px' }}>üì•</span>
                                Import
                            </button>
                        </div>

                        <div className="toolbar-center">
                            <span className="template-name">
                                {template.data.metadata?.name ?? 'Untitled Template'}
                            </span>
                        </div>

                        <div className="toolbar-right">
                            <button
                                className="toolbar-button enhanced-preview-button"
                                onClick={() => setShowEnhancedPreview(true)}
                                title="Preview"
                            >
                                <span style={{ fontSize: '16px', marginRight: '4px' }}>üëÅ</span>
                                Preview
                            </button>
                            {onTemplateSave && (
                                <button
                                    className="toolbar-button save-button"
                                    onClick={async () => await handleSave()}
                                    disabled={isSaving}
                                    title="Save (Ctrl+S)"
                                >
                                    <span style={{ fontSize: '16px', marginRight: '4px' }}>{isSaving ? '‚è≥' : 'üíæ'}</span>
                                    Save
                                </button>
                            )}
                        </div>
                    </div>
                )}

                <div className="editor-content">

                    {/* Main Canvas */}
                    <div className="canvas-wrapper">
                        <ErrorBoundary
                            resetKeys={[editorState.present.length]}
                            onError={(error) => console.error('Canvas error:', error)}
                        >
                            <CanvasDndKit
                                elements={editorState.present}
                                selectedElementId={editorState.selectedElementId}
                                onElementAdd={handleElementAdd}
                                onElementSelect={handleElementSelect}
                                onElementUpdate={handleElementUpdate}
                                onElementDelete={handleElementDelete}
                                onElementMove={handleElementMove}
                                isPreviewMode={isPreviewMode}
                            />
                        </ErrorBoundary>
                    </div>

                    {/* Right Side Panel with Tabs */}
                    {!isPreviewMode && (
                        <div className={`right-panel ${rightPanelCollapsed ? 'collapsed' : 'expanded'}`}>
                            <div className="right-panel-header">
                                <div className="panel-tabs">
                                    <button
                                        className={`tab-button ${activeRightTab === 'components' ? 'active' : ''}`}
                                        onClick={() => setActiveRightTab('components')}
                                    >
                                        üì¶ Components
                                    </button>
                                    <button
                                        className={`tab-button ${activeRightTab === 'properties' ? 'active' : ''}`}
                                        onClick={() => setActiveRightTab('properties')}
                                    >
                                        ‚öôÔ∏è Properties
                                    </button>
                                </div>
                                <button
                                    className="panel-toggle-button"
                                    onClick={() => setRightPanelCollapsed(!rightPanelCollapsed)}
                                    title={rightPanelCollapsed ? 'Expand Panel' : 'Collapse Panel'}
                                >
                                    {rightPanelCollapsed ? '‚óÄ' : '‚ñ∂'}
                                </button>
                            </div>

                            <div className="right-panel-content">
                                {activeRightTab === 'components' && (
                                    <ErrorBoundary
                                        resetKeys={[rightPanelCollapsed ? 'collapsed' : 'expanded']}
                                        onError={(error) => console.error('ComponentsPanel error:', error)}
                                    >
                                        <ComponentsPanelDndKit
                                            onComponentDrag={() => { /* Handle component drag */ }}
                                            isCollapsed={false}
                                            onToggleCollapse={() => {}}
                                        />
                                    </ErrorBoundary>
                                )}

                                {activeRightTab === 'properties' && (
                                    <ErrorBoundary
                                        resetKeys={[selectedElement?.id ?? 'none', rightPanelCollapsed ? 'collapsed' : 'expanded']}
                                        onError={(error) => console.error('PropertiesPanel error:', error)}
                                    >
                                        <PropertiesPanel
                                            selectedElement={selectedElement}
                                            onElementUpdate={handleElementUpdate}
                                            isCollapsed={false}
                                            onToggleCollapse={() => {}}
                                        />
                                    </ErrorBoundary>
                                )}
                            </div>
                        </div>
                    )}
                </div>

                <EnhancedPreviewModal
                    isOpen={showEnhancedPreview}
                    onClose={() => setShowEnhancedPreview(false)}
                    elements={editorState.present}
                    templateName={template.data.metadata?.name ?? 'Email Template'}
                />

                <ImportMjmlModal
                    isOpen={showImportModal}
                    onClose={() => setShowImportModal(false)}
                    onImport={handleImportMjml}
                />

                <DragOverlay>
                    {activeComponent && (
                        <div className="dragging-component-preview">
                            <div className="component-icon">
                                {activeComponent.icon}
                            </div>
                            <div className="component-name">
                                {activeComponent.displayName}
                            </div>
                        </div>
                    )}
                    {activeId && !activeComponent && activeDragData?.element && (
                        <div className="dragging-element-preview">
                            {activeDragData.element.tagName}
                        </div>
                    )}
                </DragOverlay>
            </div>
        </DndContext>
    )
}

export default EnhancedMjmlEditorDndKit
